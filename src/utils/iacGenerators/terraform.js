/**
 * Terraform IaC Generator
 * Generates Terraform HCL configuration for cloud subnets
 */

/**
 * Generate Terraform configuration for AWS VPC and subnets
 * @param {Object} config - VPC configuration
 * @returns {string} - Terraform HCL code
 */
export function generateAWSTerraform(config) {
  const { vpcCidr, vpcName = 'main', region = 'us-east-1', subnets = [] } = config;
  
  let tf = `# ============================================
# AWS VPC and Subnet Configuration
# Generated by Subnet Zero
# ============================================

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "${region}"
}

# ─────────────────────────────────────────
# VPC
# ─────────────────────────────────────────

resource "aws_vpc" "${sanitizeName(vpcName)}" {
  cidr_block           = "${vpcCidr}"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${vpcName}"
    ManagedBy   = "Terraform"
    GeneratedBy = "SubnetZero"
  }
}

# ─────────────────────────────────────────
# Internet Gateway
# ─────────────────────────────────────────

resource "aws_internet_gateway" "${sanitizeName(vpcName)}_igw" {
  vpc_id = aws_vpc.${sanitizeName(vpcName)}.id

  tags = {
    Name = "${vpcName}-igw"
  }
}

`;

  // Group subnets by tier for route tables
  const publicSubnets = subnets.filter(s => s.tier === 'public');

  // Add subnets
  tf += `# ─────────────────────────────────────────
# Subnets
# ─────────────────────────────────────────

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeName(subnet.name);
    const isPublic = subnet.tier === 'public';
    
    tf += `resource "aws_subnet" "${resourceName}" {
  vpc_id                  = aws_vpc.${sanitizeName(vpcName)}.id
  cidr_block              = "${subnet.cidr}"
  availability_zone       = "${subnet.az || region + 'a'}"
  map_public_ip_on_launch = ${isPublic}

  tags = {
    Name = "${subnet.name}"
    Tier = "${subnet.tier || 'private'}"
  }
}

`;
  });

  // Add route tables
  if (publicSubnets.length > 0) {
    tf += `# ─────────────────────────────────────────
# Route Tables
# ─────────────────────────────────────────

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.${sanitizeName(vpcName)}.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.${sanitizeName(vpcName)}_igw.id
  }

  tags = {
    Name = "${vpcName}-public-rt"
  }
}

`;

    // Associate public subnets with public route table
    publicSubnets.forEach(subnet => {
      const resourceName = sanitizeName(subnet.name);
      tf += `resource "aws_route_table_association" "${resourceName}" {
  subnet_id      = aws_subnet.${resourceName}.id
  route_table_id = aws_route_table.public.id
}

`;
    });
  }

  // Add outputs
  tf += `# ─────────────────────────────────────────
# Outputs
# ─────────────────────────────────────────

output "vpc_id" {
  description = "The ID of the VPC"
  value       = aws_vpc.${sanitizeName(vpcName)}.id
}

output "vpc_cidr" {
  description = "The CIDR block of the VPC"
  value       = aws_vpc.${sanitizeName(vpcName)}.cidr_block
}

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeName(subnet.name);
    tf += `output "${resourceName}_subnet_id" {
  description = "The ID of ${subnet.name} subnet"
  value       = aws_subnet.${resourceName}.id
}

`;
  });

  return tf;
}

/**
 * Generate Terraform configuration for Azure VNet and subnets
 * @param {Object} config - VNet configuration
 * @returns {string} - Terraform HCL code
 */
export function generateAzureTerraform(config) {
  const { 
    vpcCidr, 
    vpcName = 'main-vnet', 
    region = 'eastus', 
    resourceGroup = 'rg-network',
    subnets = [] 
  } = config;
  
  let tf = `# ============================================
# Azure VNet and Subnet Configuration
# Generated by Subnet Zero
# ============================================

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

# ─────────────────────────────────────────
# Resource Group
# ─────────────────────────────────────────

resource "azurerm_resource_group" "${sanitizeName(resourceGroup)}" {
  name     = "${resourceGroup}"
  location = "${region}"

  tags = {
    ManagedBy   = "Terraform"
    GeneratedBy = "SubnetZero"
  }
}

# ─────────────────────────────────────────
# Virtual Network
# ─────────────────────────────────────────

resource "azurerm_virtual_network" "${sanitizeName(vpcName)}" {
  name                = "${vpcName}"
  location            = azurerm_resource_group.${sanitizeName(resourceGroup)}.location
  resource_group_name = azurerm_resource_group.${sanitizeName(resourceGroup)}.name
  address_space       = ["${vpcCidr}"]

  tags = {
    Name        = "${vpcName}"
    ManagedBy   = "Terraform"
    GeneratedBy = "SubnetZero"
  }
}

# ─────────────────────────────────────────
# Subnets
# ─────────────────────────────────────────

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeName(subnet.name);
    
    tf += `resource "azurerm_subnet" "${resourceName}" {
  name                 = "${subnet.name}"
  resource_group_name  = azurerm_resource_group.${sanitizeName(resourceGroup)}.name
  virtual_network_name = azurerm_virtual_network.${sanitizeName(vpcName)}.name
  address_prefixes     = ["${subnet.cidr}"]
}

`;
  });

  // Add outputs
  tf += `# ─────────────────────────────────────────
# Outputs
# ─────────────────────────────────────────

output "vnet_id" {
  description = "The ID of the Virtual Network"
  value       = azurerm_virtual_network.${sanitizeName(vpcName)}.id
}

output "vnet_name" {
  description = "The name of the Virtual Network"
  value       = azurerm_virtual_network.${sanitizeName(vpcName)}.name
}

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeName(subnet.name);
    tf += `output "${resourceName}_subnet_id" {
  description = "The ID of ${subnet.name} subnet"
  value       = azurerm_subnet.${resourceName}.id
}

`;
  });

  return tf;
}

/**
 * Generate Terraform configuration for GCP VPC and subnets
 * @param {Object} config - VPC configuration
 * @returns {string} - Terraform HCL code
 */
export function generateGCPTerraform(config) {
  const { 
    vpcName = 'main-vpc', 
    projectId = 'my-project',
    region = 'us-central1',
    subnets = [] 
  } = config;
  
  let tf = `# ============================================
# GCP VPC and Subnet Configuration
# Generated by Subnet Zero
# ============================================

terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = "${projectId}"
  region  = "${region}"
}

# ─────────────────────────────────────────
# VPC Network
# ─────────────────────────────────────────

resource "google_compute_network" "${sanitizeName(vpcName)}" {
  name                    = "${vpcName}"
  auto_create_subnetworks = false
  routing_mode            = "REGIONAL"
}

# ─────────────────────────────────────────
# Subnets
# ─────────────────────────────────────────

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeName(subnet.name);
    const subnetRegion = subnet.region || region;
    
    tf += `resource "google_compute_subnetwork" "${resourceName}" {
  name          = "${subnet.name}"
  ip_cidr_range = "${subnet.cidr}"
  region        = "${subnetRegion}"
  network       = google_compute_network.${sanitizeName(vpcName)}.id

  # Enable private Google access for private subnets
  private_ip_google_access = ${subnet.tier !== 'public'}
}

`;
  });

  // Add firewall rules
  tf += `# ─────────────────────────────────────────
# Firewall Rules
# ─────────────────────────────────────────

resource "google_compute_firewall" "allow_internal" {
  name    = "${vpcName}-allow-internal"
  network = google_compute_network.${sanitizeName(vpcName)}.name

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = [${subnets.map(s => `"${s.cidr}"`).join(', ')}]
}

`;

  // Add outputs
  tf += `# ─────────────────────────────────────────
# Outputs
# ─────────────────────────────────────────

output "vpc_id" {
  description = "The ID of the VPC"
  value       = google_compute_network.${sanitizeName(vpcName)}.id
}

output "vpc_self_link" {
  description = "The self link of the VPC"
  value       = google_compute_network.${sanitizeName(vpcName)}.self_link
}

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeName(subnet.name);
    tf += `output "${resourceName}_subnet_id" {
  description = "The ID of ${subnet.name} subnet"
  value       = google_compute_subnetwork.${resourceName}.id
}

`;
  });

  return tf;
}

/**
 * Generate Terraform based on provider
 * @param {string} provider - Cloud provider (aws, azure, gcp)
 * @param {Object} config - Configuration object
 * @returns {string} - Terraform HCL code
 */
export function generateTerraform(provider, config) {
  switch (provider) {
    case 'aws':
      return generateAWSTerraform(config);
    case 'azure':
      return generateAzureTerraform(config);
    case 'gcp':
      return generateGCPTerraform(config);
    default:
      return generateAWSTerraform(config);
  }
}

/**
 * Sanitize name for Terraform resource names
 * @param {string} name - Original name
 * @returns {string} - Sanitized name
 */
function sanitizeName(name) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9_]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
}

const terraformExports = {
  generateTerraform,
  generateAWSTerraform,
  generateAzureTerraform,
  generateGCPTerraform
};

export default terraformExports;

