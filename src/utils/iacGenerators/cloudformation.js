/**
 * AWS CloudFormation Generator
 * Generates CloudFormation YAML/JSON for VPC and subnets
 */

/**
 * Generate CloudFormation template (YAML format)
 * @param {Object} config - VPC configuration
 * @returns {string} - CloudFormation YAML
 */
export function generateCloudFormationYAML(config) {
  const { vpcCidr, vpcName = 'MainVPC', subnets = [] } = config;
  
  let yaml = `# ============================================
# AWS CloudFormation VPC Template
# Generated by Subnet Zero
# ============================================

AWSTemplateFormatVersion: '2010-09-09'
Description: VPC and Subnet configuration generated by Subnet Zero

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues:
      - development
      - staging
      - production
    Description: Environment name

Resources:
  # ─────────────────────────────────────────
  # VPC
  # ─────────────────────────────────────────
  
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: ${vpcCidr}
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: ${vpcName}
        - Key: Environment
          Value: !Ref Environment
        - Key: GeneratedBy
          Value: SubnetZero

  # ─────────────────────────────────────────
  # Internet Gateway
  # ─────────────────────────────────────────
  
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: ${vpcName}-igw

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

`;

  // Add subnets
  yaml += `  # ─────────────────────────────────────────
  # Subnets
  # ─────────────────────────────────────────
  
`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeResourceName(subnet.name);
    const isPublic = subnet.tier === 'public';
    
    yaml += `  ${resourceName}Subnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: ${subnet.cidr}
      AvailabilityZone: ${subnet.az || '!Select [0, !GetAZs ""]'}
      MapPublicIpOnLaunch: ${isPublic}
      Tags:
        - Key: Name
          Value: ${subnet.name}
        - Key: Tier
          Value: ${subnet.tier || 'private'}
        - Key: Environment
          Value: !Ref Environment

`;
  });

  // Add route tables
  const publicSubnets = subnets.filter(s => s.tier === 'public');
  const privateSubnets = subnets.filter(s => s.tier !== 'public');

  if (publicSubnets.length > 0) {
    yaml += `  # ─────────────────────────────────────────
  # Route Tables
  # ─────────────────────────────────────────
  
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: ${vpcName}-public-rt

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

`;

    publicSubnets.forEach(subnet => {
      const resourceName = sanitizeResourceName(subnet.name);
      yaml += `  ${resourceName}RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref ${resourceName}Subnet
      RouteTableId: !Ref PublicRouteTable

`;
    });
  }

  if (privateSubnets.length > 0) {
    yaml += `  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: ${vpcName}-private-rt

`;

    privateSubnets.forEach(subnet => {
      const resourceName = sanitizeResourceName(subnet.name);
      yaml += `  ${resourceName}RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref ${resourceName}Subnet
      RouteTableId: !Ref PrivateRouteTable

`;
    });
  }

  // Add outputs
  yaml += `# ─────────────────────────────────────────
# Outputs
# ─────────────────────────────────────────

Outputs:
  VpcId:
    Description: VPC ID
    Value: !Ref VPC
    Export:
      Name: !Sub '\${AWS::StackName}-VpcId'

  VpcCidr:
    Description: VPC CIDR Block
    Value: !GetAtt VPC.CidrBlock
    Export:
      Name: !Sub "\${AWS::StackName}-VpcCidr"

`;

  subnets.forEach(subnet => {
    const resourceName = sanitizeResourceName(subnet.name);
    yaml += `  ${resourceName}SubnetId:
    Description: ${subnet.name} Subnet ID
    Value: !Ref ${resourceName}Subnet
    Export:
      Name: !Sub "\${AWS::StackName}-${resourceName}SubnetId"

`;
  });

  return yaml;
}

/**
 * Generate CloudFormation template (JSON format)
 * @param {Object} config - VPC configuration
 * @returns {string} - CloudFormation JSON
 */
export function generateCloudFormationJSON(config) {
  const { vpcCidr, vpcName = 'MainVPC', subnets = [] } = config;
  
  const template = {
    AWSTemplateFormatVersion: '2010-09-09',
    Description: 'VPC and Subnet configuration generated by Subnet Zero',
    
    Parameters: {
      Environment: {
        Type: 'String',
        Default: 'production',
        AllowedValues: ['development', 'staging', 'production'],
        Description: 'Environment name'
      }
    },
    
    Resources: {
      VPC: {
        Type: 'AWS::EC2::VPC',
        Properties: {
          CidrBlock: vpcCidr,
          EnableDnsHostnames: true,
          EnableDnsSupport: true,
          Tags: [
            { Key: 'Name', Value: vpcName },
            { Key: 'Environment', Value: { Ref: 'Environment' } },
            { Key: 'GeneratedBy', Value: 'SubnetZero' }
          ]
        }
      },
      
      InternetGateway: {
        Type: 'AWS::EC2::InternetGateway',
        Properties: {
          Tags: [{ Key: 'Name', Value: `${vpcName}-igw` }]
        }
      },
      
      InternetGatewayAttachment: {
        Type: 'AWS::EC2::VPCGatewayAttachment',
        Properties: {
          InternetGatewayId: { Ref: 'InternetGateway' },
          VpcId: { Ref: 'VPC' }
        }
      }
    },
    
    Outputs: {
      VpcId: {
        Description: 'VPC ID',
        Value: { Ref: 'VPC' },
        Export: { Name: { 'Fn::Sub': '${AWS::StackName}-VpcId' } }
      },
      VpcCidr: {
        Description: 'VPC CIDR Block',
        Value: { 'Fn::GetAtt': ['VPC', 'CidrBlock'] },
        Export: { Name: { 'Fn::Sub': '${AWS::StackName}-VpcCidr' } }
      }
    }
  };

  // Add subnets
  subnets.forEach(subnet => {
    const resourceName = sanitizeResourceName(subnet.name);
    const isPublic = subnet.tier === 'public';
    
    template.Resources[`${resourceName}Subnet`] = {
      Type: 'AWS::EC2::Subnet',
      Properties: {
        VpcId: { Ref: 'VPC' },
        CidrBlock: subnet.cidr,
        AvailabilityZone: subnet.az || { 'Fn::Select': [0, { 'Fn::GetAZs': '' }] },
        MapPublicIpOnLaunch: isPublic,
        Tags: [
          { Key: 'Name', Value: subnet.name },
          { Key: 'Tier', Value: subnet.tier || 'private' },
          { Key: 'Environment', Value: { Ref: 'Environment' } }
        ]
      }
    };
    
    template.Outputs[`${resourceName}SubnetId`] = {
      Description: `${subnet.name} Subnet ID`,
      Value: { Ref: `${resourceName}Subnet` },
      Export: { Name: { 'Fn::Sub': `\${AWS::StackName}-${resourceName}SubnetId` } }
    };
  });

  // Add route tables for public subnets
  const publicSubnets = subnets.filter(s => s.tier === 'public');
  
  if (publicSubnets.length > 0) {
    template.Resources.PublicRouteTable = {
      Type: 'AWS::EC2::RouteTable',
      Properties: {
        VpcId: { Ref: 'VPC' },
        Tags: [{ Key: 'Name', Value: `${vpcName}-public-rt` }]
      }
    };
    
    template.Resources.PublicRoute = {
      Type: 'AWS::EC2::Route',
      DependsOn: 'InternetGatewayAttachment',
      Properties: {
        RouteTableId: { Ref: 'PublicRouteTable' },
        DestinationCidrBlock: '0.0.0.0/0',
        GatewayId: { Ref: 'InternetGateway' }
      }
    };
    
    publicSubnets.forEach(subnet => {
      const resourceName = sanitizeResourceName(subnet.name);
      template.Resources[`${resourceName}RouteTableAssociation`] = {
        Type: 'AWS::EC2::SubnetRouteTableAssociation',
        Properties: {
          SubnetId: { Ref: `${resourceName}Subnet` },
          RouteTableId: { Ref: 'PublicRouteTable' }
        }
      };
    });
  }

  return JSON.stringify(template, null, 2);
}

/**
 * Sanitize name for CloudFormation resource names
 * @param {string} name - Original name
 * @returns {string} - Sanitized name (PascalCase)
 */
function sanitizeResourceName(name) {
  return name
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

const cloudformationExports = {
  generateCloudFormationYAML,
  generateCloudFormationJSON
};

export default cloudformationExports;

